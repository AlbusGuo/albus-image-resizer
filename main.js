/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageResizePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  resizeInterval: 0,
  edgeSize: 20
};
var ImageResizeSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("拖动调整图片大小").setHeading();
    new import_obsidian2.Setting(containerEl).setName("调整大小的时间间隔").setDesc("拖动调整最小刻度（默认值为 0 即不对齐刻度）").addText((text) => {
      text.setValue(this.plugin.settings.resizeInterval.toString()).onChange((value) => __async(this, null, function* () {
        if (value === "") {
          this.plugin.settings.resizeInterval = 0;
          yield this.plugin.saveSettings();
        } else if (/^\d+$/.test(value) && Number(value) >= 0) {
          this.plugin.settings.resizeInterval = parseInt(value);
          yield this.plugin.saveSettings();
        } else {
          new import_obsidian2.Notice("请输入整数");
          text.setValue(this.plugin.settings.resizeInterval.toString());
        }
      }));
    });
    new import_obsidian2.Setting(containerEl).setName("边缘检测区域大小").setDesc("鼠标在图片边缘多少像素内可以触发调整大小（单位：像素）").addSlider((slider) => {
      slider.setLimits(5, 150, 1);
      slider.setValue(this.plugin.settings.edgeSize);
      slider.onChange((value) => __async(this, null, function* () {
        this.plugin.settings.edgeSize = value;
        new import_obsidian2.Notice(`边缘检测区域: ${value}px`);
        yield this.plugin.saveSettings();
      }));
      slider.setDynamicTooltip();
    });
  }
};

// src/main.ts
var ImageResizePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.updateImageLinkWithNewSize = (img, target_pos, newWidth, newHeight) => {
      var _a;
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView)
        return;
      const inTable = img.closest("table") != null;
      const inCallout = img.closest(".callout") != null;
      const isExcalidraw = img.classList.contains("excalidraw-embedded-img");
      if (activeView) {
        let imageName = img.getAttribute("src");
        if (imageName == null ? void 0 : imageName.startsWith("http")) {
          this.updateExternalLink(activeView, img, target_pos, newWidth, newHeight, inTable, inCallout);
        } else if (isExcalidraw) {
          let draw_base_name = this.getExcalidrawBaseName(img);
          img.style.maxWidth = "none";
          this.updateInternalLink(activeView, img, target_pos, draw_base_name, newWidth, newHeight, inTable, inCallout);
        } else {
          imageName = (_a = img.closest(".internal-embed")) == null ? void 0 : _a.getAttribute("src");
          this.updateInternalLink(activeView, img, target_pos, imageName, newWidth, newHeight, inTable, inCallout);
        }
      }
    };
  }
  onload() {
    return __async(this, null, function* () {
      console.log("Image Resize Plugin \u63D2\u4EF6\u5DF2\u52A0\u8F7D...");
      yield this.loadSettings();
      this.addSettingTab(new ImageResizeSettingsTab(this.app, this));
      this.registerDocument(document);
      app.workspace.on("window-open", (workspaceWindow, window2) => {
        this.registerDocument(window2.document);
      });
    });
  }
  onunload() {
    console.log("Image Resize Plugin \u63D2\u4EF6\u5DF2\u5378\u8F7D...");
  }
  registerDocument(document2) {
    this.register(this.onElement(document2, "mousedown", "img", (event) => {
      var _a, _b;
      const currentMd = app.workspace.getActiveFile();
      if (!currentMd)
        return;
      if (currentMd.name.endsWith(".canvas"))
        return;
      const inPreview = ((_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.getMode()) == "preview";
      if (inPreview)
        return;
      if (event.button === 0) {
        event.preventDefault();
      }
      const img = event.target;
      const editor = (_b = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _b.editor;
      if (!editor)
        return;
      const editorView = editor.cm;
      const target_pos = editorView.posAtDOM(img);
      let target_line = editorView.state.doc.lineAt(target_pos);
      const inTable = img.closest("table") != null;
      const inCallout = img.closest(".callout") != null;
      const isExcalidraw = img.classList.contains("excalidraw-embedded-img");
      let preventEvent = function(event2) {
        event2.preventDefault();
        event2.stopPropagation();
      };
      const rect = img.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const edgeSize = this.settings.edgeSize;
      
      // 检查是否在右下角可拖拽区域
      const isInResizeArea = x > rect.width - edgeSize && y > rect.height - edgeSize;
      
      if (isInResizeArea) {
        const startX = event.clientX;
        const startY = event.clientY;
        const startWidth = img.clientWidth;
        const startHeight = img.clientHeight;
        let lastUpdateX = startX;
        let lastUpdate = 1;
        let updatedWidth = startWidth;
        let lastMoveTime = Date.now();
        const onMouseMove = (event2) => {
          img.addEventListener("click", preventEvent);
          const currentX = event2.clientX;
          lastUpdate = currentX - lastUpdateX == 0 ? lastUpdate : currentX - lastUpdateX;
          let newWidth = startWidth + (currentX - startX);
          const aspectRatio = startWidth / startHeight;
          newWidth = Math.max(newWidth, 50);
          let newHeight = newWidth / aspectRatio;
          newWidth = Math.round(newWidth);
          newHeight = Math.round(newHeight);
          updatedWidth = newWidth;
          img.style.width = `${newWidth}px`;
          const now = Date.now();
          if (now - lastMoveTime < 100)
            return;
          lastMoveTime = now;
          this.updateImageLinkWithNewSize(img, target_pos, newWidth, newHeight);
          lastUpdateX = event2.clientX;
        };
        const allowOtherEvent = () => {
          img.removeEventListener("click", preventEvent);
        };
        const onMouseUp = (event2) => {
          setTimeout(allowOtherEvent, 100);
          event2.preventDefault();
          document2.removeEventListener("mousemove", onMouseMove);
          document2.removeEventListener("mouseup", onMouseUp);
          
          // 移除所有内联样式，确保markdown尺寸设置生效
          img.style.removeProperty("width");
          img.style.removeProperty("height");
          img.style.removeProperty("max-width");
          img.style.removeProperty("max-height");
          
          if (this.settings.resizeInterval > 1) {
            let resize_interval = this.settings.resizeInterval;
            let width_offset = lastUpdate > 0 ? resize_interval : 0;
            if (updatedWidth % resize_interval != 0) {
              updatedWidth = Math.floor(updatedWidth / resize_interval) * resize_interval + width_offset;
            }
            this.updateImageLinkWithNewSize(img, target_pos, updatedWidth, 0);
          }
        };
        document2.addEventListener("mousemove", onMouseMove);
        document2.addEventListener("mouseup", onMouseUp);
      }
    }));
    
    // 注册鼠标移动事件 - 检测是否在可拖拽区域
    this.register(this.onElement(document2, "mousemove", "img", (event) => {
      var _a;
      const currentMd = app.workspace.getActiveFile();
      if (!currentMd)
        return;
      if (currentMd.name.endsWith(".canvas"))
        return;
      const inPreview = ((_a = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a.getMode()) == "preview";
      if (inPreview)
        return;
      
      const img = event.target;
      const rect = img.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const edgeSize = this.settings.edgeSize;
      
      // 检查是否在右下角可拖拽区域
      const isInResizeArea = x > rect.width - edgeSize && y > rect.height - edgeSize;
      
      if (isInResizeArea) {
        // 在可拖拽区域，改变光标样式
        img.style.cursor = 'nwse-resize';
      } else {
        // 不在可拖拽区域，恢复默认光标
        img.style.cursor = '';
      }
    }));
    
    // 注册鼠标离开事件 - 恢复光标样式
    this.register(this.onElement(document2, "mouseleave", "img", (event) => {
      const img = event.target;
      img.style.cursor = '';
    }));
  }

  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  onElement(el, event, selector, listener, options) {
    el.on(event, selector, listener, options);
    return () => el.off(event, selector, listener, options);
  }
  updateInternalLink(activeView, target, target_pos, imageName, newWidth, newHeight, inTable, inCallout) {
    const editor = activeView.editor;
    const editorView = editor.cm;
    let target_line = editorView.state.doc.lineAt(target_pos);
    if (!inCallout && !inTable) {
      let matched = this.matchLineWithInternalLink(target_line.text, imageName, newWidth, inTable);
      if (matched.length == 1) {
        editorView.dispatch({
          changes: {
            from: target_line.from + matched[0].from_ch,
            to: target_line.from + matched[0].to_ch,
            insert: matched[0].new_link
          }
        });
      } else if (matched.length == 0) {
      } else {
        new import_obsidian.Notice("在当前行中找到多个相同的图像链接,请手动缩放!");
      }
      return;
    }
    let startReg = {
      "table": /^\s*\|/,
      "callout": /^>/
    };
    let mode = inTable ? "表格" : "callout";
    const start_reg = startReg[mode];
    let start_line_number = target_line.number;
    let matched_results = [];
    let matched_lines = [];
    for (let i = start_line_number; i <= editor.lineCount(); i++) {
      let line = editorView.state.doc.line(i);
      if (!start_reg.test(line.text))
        break;
      let matched = this.matchLineWithInternalLink(line.text, imageName, newWidth, inTable);
      matched_results.push(...matched);
      matched_lines.push(...new Array(matched.length).fill(i));
    }
    for (let i = start_line_number - 1; i >= 1; i--) {
      let line = editorView.state.doc.line(i);
      if (!start_reg.test(line.text))
        break;
      let matched = this.matchLineWithInternalLink(line.text, imageName, newWidth, inTable);
      matched_results.push(...matched);
      matched_lines.push(...new Array(matched.length).fill(i));
    }
    if (matched_results.length == 1) {
      let target_line2 = editorView.state.doc.line(matched_lines[0]);
      if (mode == "table") {
        let old_text = target_line2.text;
        let new_line_text = old_text.substring(0, matched_results[0].from_ch) + matched_results[0].new_link + old_text.substring(matched_results[0].to_ch);
        editorView.dispatch({
          changes: {
            from: target_line2.from,
            to: target_line2.from + old_text.length,
            insert: new_line_text
          }
        });
      } else {
        editorView.dispatch({
          changes: {
            from: target_line2.from + matched_results[0].from_ch,
            to: target_line2.from + matched_results[0].to_ch,
            insert: matched_results[0].new_link
          }
        });
      }
    } else if (matched_results.length == 0) {
      new import_obsidian.Notice(`在 ${mode} 中未能找到当前图像链接,请手动缩放!`);
    } else {
      new import_obsidian.Notice(`在 ${mode} 中找到多个相同的图像链接,请手动缩放!`);
    }
    return;
  }
  updateExternalLink(activeView, target, target_pos, newWidth, newHeight, inTable, inCallout) {
    const editor = activeView.editor;
    const editorView = editor.cm;
    let target_line = editorView.state.doc.lineAt(target_pos);
    const link = target.getAttribute("src");
    const altText = target.getAttribute("alt");
    if (!inCallout && !inTable) {
      let matched = this.matchLineWithExternalLink(target_line.text, link, altText, newWidth, inTable);
      if (matched.length == 1) {
        editorView.dispatch({
          changes: {
            from: target_line.from + matched[0].from_ch,
            to: target_line.from + matched[0].to_ch,
            insert: matched[0].new_link
          }
        });
      } else if (matched.length == 0) {
      } else {
        new import_obsidian.Notice("在当前行中找到多个相同的图像链接,请手动缩放!");
      }
      return;
    }
    let startReg = {
      "table": /^\s*\|/,
      "callout": /^>/
    };
    let mode = inTable ? "表格" : "callout";
    const start_reg = startReg[mode];
    let start_line_number = target_line.number;
    let matched_results = [];
    let matched_lines = [];
    for (let i = start_line_number; i <= editor.lineCount(); i++) {
      let line = editorView.state.doc.line(i);
      if (!start_reg.test(line.text))
        break;
      let matched = this.matchLineWithExternalLink(line.text, link, altText, newWidth, inTable);
      matched_results.push(...matched);
      matched_lines.push(...new Array(matched.length).fill(i));
    }
    for (let i = start_line_number - 1; i >= 1; i--) {
      let line = editorView.state.doc.line(i);
      if (!start_reg.test(line.text))
        break;
      let matched = this.matchLineWithExternalLink(line.text, link, altText, newWidth, inTable);
      matched_results.push(...matched);
      matched_lines.push(...new Array(matched.length).fill(i));
    }
    if (matched_results.length == 1) {
      let target_line2 = editorView.state.doc.line(matched_lines[0]);
      if (mode == "table") {
        let old_text = target_line2.text;
        let new_line_text = old_text.substring(0, matched_results[0].from_ch) + matched_results[0].new_link + old_text.substring(matched_results[0].to_ch);
        editorView.dispatch({
          changes: {
            from: target_line2.from,
            to: target_line2.from + old_text.length,
            insert: new_line_text
          }
        });
      } else {
        editorView.dispatch({
          changes: {
            from: target_line2.from + matched_results[0].from_ch,
            to: target_line2.from + matched_results[0].to_ch,
            insert: matched_results[0].new_link
          }
        });
      }
    } else if (matched_results.length == 0) {
      new import_obsidian.Notice(`在 ${mode} 中未能找到当前图像链接,请手动缩放!`);
    } else {
      new import_obsidian.Notice(`在 ${mode} 中找到多个相同的图像链接,请手动缩放!`);
    }
    return;
  }
  matchLineWithInternalLink(line_text, target_name, new_width, intable) {
    let regWikiLink = /\!\[\[[^\[\]]*?\]\]/g;
    let regMdLink = /\!\[[^\[\]]*?\]\(\s*[^\[\]\{\}']*\s*\)/g;
    const target_name_mdlink = target_name.replace(/ /g, "%20");
    if (!line_text.includes(target_name) && !line_text.includes(target_name_mdlink))
      return [];
    let result = [];
    while (true) {
      let wiki_match = regWikiLink.exec(line_text);
      if (!wiki_match)
        break;
      const matched_link = wiki_match[0];
      if (matched_link.includes(target_name)) {
        let normal_link = intable ? matched_link.replace(/\\\|/g, "|") : matched_link;
        let link_match = normal_link.match(/!\[\[(.*?)(\||\]\])/);
        let link_text = link_match ? link_match[1] : "";
        let alt_match = matched_link.match(/!\[\[.*?(\|(.*?))\]\]/);
        let alt_text = alt_match ? alt_match[1] : "";
        let alt_text_list = alt_text.split("|");
        let alt_text_wo_size = "";
        let new_alt_text = "";
        for (let alt of alt_text_list) {
          if (!/^\d+$/.test(alt) && !/^\s*$/.test(alt)) {
            alt_text_wo_size = alt_text_wo_size + "|" + alt;
          }
        }
        new_alt_text = new_width != 0 ? `${alt_text_wo_size}|${new_width}` : alt_text_wo_size;
        new_alt_text = intable ? new_alt_text.replace(/\|/g, "\\|") : new_alt_text;
        let newWikiLink = link_match ? `![[${link_text}${new_alt_text}]]` : `![[${target_name}${new_alt_text}]]`;
        result.push({
          old_link: matched_link,
          new_link: newWikiLink,
          from_ch: wiki_match.index,
          to_ch: wiki_match.index + matched_link.length
        });
      }
    }
    while (true) {
      let match = regMdLink.exec(line_text);
      if (!match)
        break;
      const matched_link = match[0];
      if (matched_link.includes(target_name_mdlink)) {
        let alt_text_match = matched_link.match(/\[.*?\]/g);
        let alt_text = alt_text_match[0].substring(1, alt_text_match[0].length - 1);
        let pure_alt = alt_text.replace(/\|\d+(\|\d+)?$/g, "");
        if (intable) {
          pure_alt = alt_text.replace(/\\\|\d+(\|\d+)?$/g, "");
        }
        let link_text = matched_link.substring(alt_text_match[0].length + 2, matched_link.length - 1);
        let newMDLink = intable ? `![${pure_alt}\\|${new_width}](${link_text})` : `![${pure_alt}|${new_width}](${link_text})`;
        if (/^\d*$/.test(alt_text)) {
          newMDLink = `![${new_width}](${link_text})`;
        }
        result.push({
          old_link: matched_link,
          new_link: newMDLink,
          from_ch: match.index,
          to_ch: match.index + matched_link.length
        });
      }
    }
    return result;
  }
  matchLineWithExternalLink(line_text, link, alt_text, new_width, intable) {
    let result = [];
    let regMdLink = /\!\[[^\[\]]*?\]\(\s*[^\[\]\{\}']*\s*\)/g;
    if (!line_text.includes(link))
      return [];
    while (true) {
      let match = regMdLink.exec(line_text);
      if (!match)
        break;
      let matched_link = match[0];
      if (matched_link.includes(link)) {
        let alt_text_match = matched_link.match(/\[.*?\]/g);
        let alt_text2 = alt_text_match[0].substring(1, alt_text_match[0].length - 1);
        let pure_alt = alt_text2.replace(/\|\d+(\|\d+)?$/g, "");
        if (intable) {
          pure_alt = alt_text2.replace(/\\\|\d+(\|\d+)?$/g, "");
        }
        if (/^\d*$/.test(alt_text2)) {
          pure_alt = "";
        }
        let link_text = matched_link.substring(alt_text_match[0].length + 2, matched_link.length - 1);
        let newExternalLink = intable ? `![${pure_alt}\\|${new_width}](${link_text})` : `![${pure_alt}|${new_width}](${link_text})`;
        result.push({
          old_link: matched_link,
          new_link: newExternalLink,
          from_ch: match.index,
          to_ch: match.index + matched_link.length
        });
      }
    }
    return result;
  }
  getExcalidrawBaseName(target) {
    let target_name = target.getAttribute("filesource");
    let file_base_name = target_name;
    if (file_base_name.includes("/")) {
      let temp_arr = file_base_name.split("/");
      file_base_name = temp_arr[temp_arr.length - 1];
    } else if (file_base_name.includes("\\")) {
      let temp_arr = file_base_name.split("\\");
      file_base_name = temp_arr[temp_arr.length - 1];
    }
    file_base_name = file_base_name.endsWith(".md") ? file_base_name.substring(0, file_base_name.length - 3) : file_base_name;
    return file_base_name;
  }
};